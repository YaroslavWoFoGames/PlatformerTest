PlatformerTest
Привет!

Перед вами небольшой тестовый проект — платформер, который я собрал, чтобы показать подход к архитектуре и реализации фич за ограниченное время  (~12 часов). Это компромисс между качеством и скоростью разработки.

Что у меня там под капотом?)
Основные подходы
Dependency Injection (DI)
В проекте используется Zenject для контекстов и биндов сервисов.
Точка входа реализована через EntryPoint. Для больших проектов я обычно использую Scriptable Installers, чтобы четко разделить логику каждого сервиса.

Архитектура на основе сервисов
Полные реализации:

InputService — работает на новой системе ввода Unity.
UIService — отвечает за взаимодействие с интерфейсом.
GameStateService — управляет игровыми состояниями.
Упрощенные:

SceneLoadingService — загрузка сцен.
AudioService — базовая аудио-операции.
State Machine
Управление игровыми состояниями происходит через State Machine, которая использует сервис-локатор DI-контейнера. Основные состояния:

LaunchState — загрузка стартовой логики.
LevelPlayState — игровая логика.
DiedState — смерть игрока.
ExitGameState — выход из игры.
MVVM + MVC
Взаимодействие UI реализовано через MVVM (реактивные свойства), а игровая логика строится на MVC (контроллеры взаимодействуют с объектами сцены) ну и не только. Про паттерны, можно и еще что-то сказать, но это основное).

Структура проекта
Проект организован следующим образом:

Core:
Сервисы, которые обеспечивают ключевую функциональность: InputService, GameStateService, UIService.
SceneControllers:
Управление объектами на сцене (игрок, враги, лут).
States:
Игровые состояния — запуск, игра, смерть, выход.
Views:
Вьюшки для интерфейса — панели, попапы, статистика.
Game Configurations:
Скриптаблы для настроек (аудио, враги, сцена и т.д.).
Что еще можно отметить?
Загрузка ресурсов
Использую ScriptableObject для подгрузки префабов. Обычно я делаю отдельный Resource Service для работы с ресурсами (через Addressables или дефолтные механики Unity), но здесь это не потребовалось.

Пулинг объектов и UI
Для оптимизации использую LeanPool. Хотел реализовать динамическую систему для Health Bar'ов (чтобы только видимые на экране элементы отрисовывались из пула), но для такого простого проекта это переусложнение.

Сцены и контроллеры
Сцены управляются через контроллеры. Это удобно для прототипа, но в больших проектах я бы вынес более глобальную систему работы со контроллерами на сценах.

Настройка проекта
Работаю в Rider, настроенном под себя. На больших проектах предпочитаю использовать общий .editorconfig для команды.

Как это работает?
Auto Launcher запускает стартовую сцену (Launch Scene).
Инициализация идет через проектный контекст Zenject.
Точка входа создает стартовое состояние LaunchState, после чего переключается на LevelPlayState, где работает основная игровая логика.
Состояния обмениваются данными с UI через реактивные свойства.
Что можно было улучшить дальше?
Вынести отдельные сервисы для работы с передвижением, уроном и т.п. из контроллеров
Сделать более правильную анимацию (но для тестового задания в этом не было смысла).
Реализовать динамическую подгрузку конфигов из Google Sheets, а также системы сейвов и локализации (если идти дальше в увеличение).
Ну и может где-то кодстайлик не заметил что-то, хотя пользуюсь форматированием. "Все не без греха)"
Ну и еще есть вещи, но в принципе я доволен собой).
В общем, это упрощенная версия, где я сфокусировался на ключевых аспектах: сервисы, стейт-машина, и простая, но понятная структура. Если есть вопросы или предложения — пишите!
